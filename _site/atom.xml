<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Dolphin</title>
 <link href="http://mastery001.github.io/" rel="self"/>
 <link href="http://mastery001.github.io"/>
 <updated>2015-08-15T14:10:16+08:00</updated>
 <id>http://mastery001.github.io</id>
 <author>
   <name>Feng Ling</name>
   <email></email>
 </author>

 
 <entry>
   <title>Eclipse下构建SpringMVC的Maven项目</title>
   <link href="http://mastery001.github.io/maven/2015/08/15/buildMavenSpringMVCProject_InEclipse"/>
   <updated>2015-08-15T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/maven/2015/08/15/buildMavenSpringMVCProject_InEclipse</id>
   <content type="html">&lt;p&gt;最近在学习Spring、SpringMVC、Maven，想在Eclipse下构建maven项目，不过由于是第一次操作且Eclipse默认支持的创建
org-archetype-webapp需要修改许多的配置，所以望在此分享给大家，&lt;/p&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;1.引言&lt;/h1&gt;

&lt;p&gt;最近在学习Spring、SpringMVC、Maven，想在Eclipse下构建maven项目，不过由于是第一次操作且Eclipse默认支持的创建
org-archetype-webapp需要修改许多的配置，所以望在此分享给大家，可以让以后在构建的过程中不用花太多时间。&lt;/p&gt;

&lt;h1 id=&quot;eclipsemavenspringmvc&quot;&gt;2.eclipse下使用maven构建SpringMVC&lt;/h1&gt;

&lt;p&gt;在eclipse官网下载的Eclipse IDE for Java EE Developers的版本默认是已经安装了m2e插件的，所以大家不需要去重新安装；&lt;/p&gt;

&lt;p&gt;我使用的是maven3.3.3和Eclipse4.4.2&lt;/p&gt;

&lt;p&gt;1)maven下载链接：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;maven3.3.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2)eclipse下载链接：&lt;a href=&quot;http://www.eclipse.org/downloads/&quot;&gt;eclipse&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3)如果eclipse下没有m2e的插件，可参考&lt;a href=&quot;http://blog.csdn.net/wode_dream/article/details/38052639&quot;&gt;eclipse下安装m2e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notes:最后将eclipse中的maven版本配置成本地的maven，配置方式如下图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在eclipse中点击Window-&amp;gt;Maven-&amp;gt;Installations-&amp;gt;Add;之后添加自己本地的maven路径就行；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_maven_path.jpg&quot; alt=&quot;config_maven_path&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_maven_path1.jpg&quot; alt=&quot;config_maven_path1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;软件已经准备好了！那么我们开始构建maven项目吧！&lt;/p&gt;

&lt;h2 id=&quot;mavenweb&quot;&gt;maven构建web项目&lt;/h2&gt;

&lt;p&gt;点击Eclipse上方的File-&amp;gt;New-&amp;gt;Other-&amp;gt;Maven Project-&amp;gt;Next-&amp;gt;Next（这里默认就好）-&amp;gt;选择maven-archetype-webapp-&amp;gt;Next
-&amp;gt;填写project信息-&amp;gt;Finish&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/create_maven_app.jpg&quot; alt=&quot;create_maven_app&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/create_maven_app1.jpg&quot; alt=&quot;create_maven_app1&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Notes：由于Eclipse创建的Maven项目默认的web版本是2.3的，且没有加入servlet的依赖包，而且可能
会没有`src/main/java`和`src/main/test`这两个目录，所以下面我们就来解决这个问题。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jdk&quot;&gt;1)更改项目的默认jdk&lt;/h3&gt;

&lt;p&gt;右键项目根路径-&amp;gt;点击Properties&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_path.jpg&quot; alt=&quot;config_path&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_path1.jpg&quot; alt=&quot;config_path1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_path2.jpg&quot; alt=&quot;config_path2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_path3.jpg&quot; alt=&quot;config_path3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_path4.jpg&quot; alt=&quot;config_path4&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果上一步的Server Runtime没有选项，则可以如下图配置tomcat为服务器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_path5.jpg&quot; alt=&quot;config_path5&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2)更改配置文件&lt;/h3&gt;

&lt;p&gt;切换视图为Navigator,&lt;strong&gt;[由于不方便截图，文字描述]选择Window-&amp;gt;Show View-&amp;gt;Other-&amp;gt;Navigator]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/config_file.jpg&quot; alt=&quot;config_file&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.将org.eclipse.wst.common.component配置文件中的project-version的1.5.0修改为1.6.0

2.将org.eclipse.wst.common.project.facet.core.xml的jst.web对应的version修改为2.5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，我们的maven项目准备工作就做好了，下面我们开始编写SpringMVC的程序吧！&lt;/p&gt;

&lt;h2 id=&quot;springmvc&quot;&gt;2.构建SpringMVC工程&lt;/h2&gt;

&lt;h3 id=&quot;spring&quot;&gt;2.1 添加Spring依赖包&lt;/h3&gt;

&lt;p&gt;用Maven POM Editor打开pom.xml，然后选择Dependencies视图，在Dependencies下点击Add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Spring的依赖包：
    Group Id: org.springframework
    Artifact Id: spring-web
    Version: 3.2.5.RELEASE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加完毕后需要将远程包加载到本地来，右键项目根路径Run As-&amp;gt;Maven install&lt;/p&gt;

&lt;p&gt;如果报错&lt;code&gt;-Dmaven.multiModuleProjectDirectory system propery is not set. Check $M2_HOME environment variable and mvn script match.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;可以设一个环境变量M2_HOME指向你的maven安装目录
然后在Window-&amp;gt;Preference-&amp;gt;Java-&amp;gt;Installed JREs-&amp;gt;Edit
在Default VM arguments中设置
-Dmaven.multiModuleProjectDirectory=$M2_HOME
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;webxmlspring-mvcxml&quot;&gt;2.2 编写web.xml和spring-mvc的xml&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;web.xml&lt;/code&gt; 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;  
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
      xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;  
      version=&quot;3.0&quot;&amp;gt;  
    &amp;lt;servlet&amp;gt;  
	&amp;lt;servlet-name&amp;gt;spring-mvc&amp;lt;/servlet-name&amp;gt;  
	&amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;  
    &amp;lt;/servlet&amp;gt;  
  
    &amp;lt;servlet-mapping&amp;gt;  
	&amp;lt;servlet-name&amp;gt;spring-mvc&amp;lt;/servlet-name&amp;gt;  
	&amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;  
    &amp;lt;/servlet-mapping&amp;gt;  
&amp;lt;/web-app&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;spring-mvc-servlet.xml&lt;/code&gt; 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  
    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
    xsi:schemaLocation=&quot;  
	http://www.springframework.org/schema/beans       
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd  
	http://www.springframework.org/schema/context   
	http://www.springframework.org/schema/context/spring-context-3.0.xsd  
	http://www.springframework.org/schema/mvc  
	http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&amp;gt;  
  
    &amp;lt;context:component-scan base-package=&quot;cn.springmvc.controller&quot; /&amp;gt;  
    &amp;lt;bean id=&quot;viewResolver&quot;  
	class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;  
	&amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&amp;gt;  
	&amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&amp;gt;  
    &amp;lt;/bean&amp;gt;  
&amp;lt;/beans&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要在WEB-INF目录下创建views目录并创建HelloWorld.jsp文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
    pageEncoding=&quot;UTF-8&quot;%&amp;gt;
    &amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
    &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt;title&amp;gt;
    &amp;lt;/meta&amp;gt;head&amp;gt;
    &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;message:₵{message}&amp;lt;/h1&amp;gt;h1&amp;gt;
    &amp;lt;/body&amp;gt;body&amp;gt;
    &amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且需要在&lt;code&gt;src/main/java&lt;/code&gt;下建立一个控制层，包名cn.springmvc.controller，类名为Hello.java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package cn.springmvc.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class Hello {
    
    @RequestMapping(&quot;/hello&quot;)
    public String HelloWorld(Model model) {
        model.addAttribute(&quot;message&quot; , &quot;Hello World!!&quot;);
        return &quot;HelloWorld&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;运行程序&lt;/h3&gt;

&lt;p&gt;右键项目根路径Run As-&amp;gt;Run On Server-&amp;gt;Next-&amp;gt;Finish&lt;/p&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/maven_in_eclipse/result.jpg&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>随手记</title>
   <link href="http://mastery001.github.io/notes/2015/08/04/notes_001"/>
   <updated>2015-08-04T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/notes/2015/08/04/notes_001</id>
   <content type="html">&lt;!--more--&gt;

&lt;p&gt;有时候，心里有事，很想找个人倾诉，于是打电话，”没人接啊，睡觉吧。”第二天，电话拨回来，可是你已经没了想说的情绪。
有时候，看到一件衣服很喜欢，没适合码，过几天有了，你却已经失去了拥有的欲望。 
曾经你喜欢上一个人，喜欢的死去活来，难以救药，喜欢到你以为再也不会这样去喜欢一个人了。
几年后，却模糊的想不起来。 原来，所有那些激情、冲动、放不开、舍不得的当下，都会随着时间，在岁月里悄悄流逝，
慢慢消散。所以，何必念念不忘，何必苦苦执着。 你是你自己的作者，又何必写那么难演的剧本。后来的后来，你会知道。
那些所有你以为过不去的过去，都会过去。握不住的沙，不如扬了它。 有时候，是我们自己想得太多，才让自己如此难受。
你的脾气赶走了很多人，但留下了最真的人。上天给了你这种活，因为它知道你强大到可以活下去。 
别在喜悦时许诺，别在忧伤时回答，别在愤怒时做决定。生命中总有那么一段时光，充满不安，可是，除了勇敢面对，
我们别无选择。 一个懂你泪水的朋友，胜过一群只懂你笑容的朋友。 有的人对你好，是因为你对他好，有的人对你好，
是因为懂得你。 幸福，从来都没有捷径，也没有完美无瑕， 只有经营，只靠真心。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Java集合类--List篇</title>
   <link href="http://mastery001.github.io/java/2015/07/27/Java_collection_List"/>
   <updated>2015-07-27T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/java/2015/07/27/Java_collection_List</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;1. 集合类概述
2. Collection接口
    2.1 List篇
        2.1.1 List遍历方式
        2.1.2 ArrayList的实现原理
        2.1.3 LinkedList的实现原理
        2.1.4 ArrayList和LinkedList比较
    2.2 List的使用场景
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;1. 集合类概述&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java中以一种比数组存储更复杂的方式来存储对象的一组对象—“容器类”，其基本类
型有List、Set和Map，它们被组织在以Collection及Map接口为根的层次结构中，称之为集合框架。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;collection&quot;&gt;2. Collection接口&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Collection的层次结构图&lt;/strong&gt;
&lt;img src=&quot;/images/java_collections/collection_interface.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;list&quot;&gt;2.1 List篇&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;List的特征是其元素以线性的方式的存储，集合中允许放重复元素。
List接口主要的实现类有：
- ArrayList() : 代表长度可以动态改变的数组；可以对元素进行随机的访问，向ArrayList
中插入与删除元素的速度慢。

- LinkedList() : 采用链表结构实现。其插入和删除的速度快。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;list-1&quot;&gt;2.1.1 List遍历方式：&lt;/h3&gt;

&lt;p&gt;(1)for循环遍历&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*   List中的get(int index)方法支持取指定下标的元素
*/
1)使用一般for循环
    for(int i = 0 ; i &amp;lt; list.size ; i ++) {
        E obj = list.get(i);
    }
2)使用增强型for循环
    for(E obj : list) {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(2)使用迭代器（Iterator）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*   Collection集合接口继承了Iterator接口，允许集合被迭代
*   迭代方式如下：
*/
Iterator&amp;lt;E&amp;gt; it = list.iterator();
while(it.hasNext()) {
    E obj = it.next();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;arraylist&quot;&gt;2.1.2 ArrayList实现原理&lt;/h3&gt;

&lt;p&gt;ArrayList部分源码分析：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
* Default initial capacity.
*/
private static final int DEFAULT_CAPACITY = 10;

// 存放元素的数组
private transient Object[] elementData;

/* 构造方法，
*   @param initialCapacity : 设置数组的初始容量
*/
public ArrayList(int initialCapacity) {
    super();
    if (initialCapacity &amp;lt; 0)
        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity);
    this.elementData = new Object[initialCapacity];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从源码可以分析出：ArrayList采用一个Object型对象数组来存放元素，默认初始容量为10。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public boolean add(E e) {
    // 当添加元素时判断数组容量超出可容纳范围时会自动扩容
    // 具体会调用grow(int minCapacity)方法
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

// 该方法会自动给数组扩大一倍,数组可被扩大的最大容量为Integer.MAX_VALUE 
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
    ....省略部分代码 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;linkedlist&quot;&gt;2.1.3 LinkedList实现原理&lt;/h3&gt;

&lt;p&gt;LinkedList采用双向链表结构来实现的,使用结点来存储数据域和连接前一个和后一个结点.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static class Node&amp;lt;E&amp;gt; {
    E item;         // 用来保存数据域
    Node&amp;lt;E&amp;gt; next;   // 下一个结点
    Node&amp;lt;E&amp;gt; prev;   // 上一个结点

    ....此处省略
}

// 代指第一个结点
transient Node&amp;lt;E&amp;gt; first;

transient Node&amp;lt;E&amp;gt; last;

// 这里只做add方法的讲解
public boolean add(E e) {
    // 链接下一个结点
    linkLast(e);
    return true;
}

void linkLast(E e) {
    // 保存当前的最后一个结点
    final Node&amp;lt;E&amp;gt; l = last;
    //创建一个新添加元素的结点，前一个结点为该链表的最后一个结点
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(l , e , null);
    // 将新结点作为最后一个结点
    last = newNode;
    // 如果未添加前最后一个结点为空，则说明此时链表没有元素，将新结点作为首结点
    // 否则将新结点链接在末尾
    if(l != null) 
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LinkedList数据结构是链式结构，具体查阅数据结构相关的书籍。&lt;/p&gt;

&lt;h3 id=&quot;arraylistlinkedlist&quot;&gt;2.1.4 ArrayList和LinkedList比较&lt;/h3&gt;

&lt;p&gt;ArrayList和LinkedList的区别：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;list-2&quot;&gt;2.2 List使用场景&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。
01) 对于需要快速插入，删除元素，应该使用LinkedList。

02) 对于需要快速随机访问元素，应该使用ArrayList。

03) 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。
    对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。
&lt;/code&gt;&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>JVM启动工作原理</title>
   <link href="http://mastery001.github.io/java/2015/07/22/JVM_start_principle"/>
   <updated>2015-07-22T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/java/2015/07/22/JVM_start_principle</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;1. JVM体系结构
2. JVM的生命周期
3. JVM启动
    3.1 JVM启动代码分析
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;jvm&quot;&gt;1. JVM体系结构&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;(1)类加载器（`ClassLoader`）（用来装载`.class`文件）

(2)执行引擎（执行字节码，或者执行本地方法）

(3)运行时数据区（方法区、堆、java栈、本地方法栈、PC寄存器）
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;jvm-1&quot;&gt;2. JVM的生命周期&lt;/h1&gt;

&lt;p&gt;1.JVM实例对应了一个独立运行的java程序，它是进程级别;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a）启动。启动一个java程序时，一个JVM实例就产生了，任何一个拥有`public static void main(String
[] args)`方法的class都可以作为JVM实例运行的起点

b）运行。`main()`作为该程序的初始线程的起点，任何其他线程均由该线程启动。JVM内部有两种线程：守护线
程和非守护线程，`main()`属于非守护线程守护线程通常由JVM自己使用，java程序也可以标明自己创建的线程
是守护线程

c）消亡。当程序中的所有非守护线程都终止时，JVM才退出；若安全管理器允许，程序也可以使用`Runtime`类
或者`System.exit()`来退出
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.JVM执行引擎实例则对应了属于用户运行程序的线程，它是线程级别的;&lt;/p&gt;

&lt;h1 id=&quot;jvm-2&quot;&gt;3. JVM启动&lt;/h1&gt;

&lt;p&gt;JVM工作原理和特点主要是指操作系统装入JVM，是通过JDK中&lt;code&gt;java.exe&lt;/code&gt;来完成，通过下面4步来完成JVM环境.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.创建`JVM`装载环境和配置

2.装载`JVM.dll`

3.初始化`JVM.dll`并挂界到`JNIENV`(`JNI`调用接口)实例

4.调用`JNIENV`实例装载并处理`class`类
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section&quot;&gt;3.1 启动代码分析&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;main&lt;/code&gt;函数在&lt;code&gt;openjdk\jdk\src\share\bin\main.c&lt;/code&gt;文件中。简单流程分析如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.SelectVersion-&amp;gt;LocateJRE,定位jre的位置。因为在不同的操作系统上定位jre的方式不同，相关代码就
和平台相关了，windows相关的一些代码在`openjdk\jdk\src\windows`下，而`linux`和`solaris`相关
代码在`openjdk\jdk\src\solaris`下。这部分调用到的代码都在`{os}\bin\java_md.c`中。简单的说，
windows中，LocateJRE要通过查找注册表来定位jre的位置，而Linux下可能需要读取环境变量等。

2.CreateExecutionEnvironment-&amp;gt;GetJVMPath得到jvm的路径，其实就是找到相应的动态链接
库，具体到linux上，就是`libjvm.so`。

3.LoadJavaVM，linux上是加载'libjvm.so',windows上是加载`jvm.dll`，导
出`JNI_CreateJavaVM`、`JNI_GetDefaultJavaVMInitArgs`等函数。

4.获取classpath。

5.ContinueInNewThread(&amp;amp;ifn,argc,argv,jarfile,classname,ret);在一个新线程中启动jvm。
ContinueInNewThread的功能是：调用`GetDefaultJavaJVMInitArgs`(其实就
调用`JNI_GetDefaultJavaVMInitArgs`)获取虚拟机初始化参数，设定线程栈的大小，
创建java程序需要的各项参数。然后调用下面函数 `ContinueInNewThread0(JavaMain, 
threadStackSize, (void*)&amp;amp;args);` ;因为不同操作系统创建线程的方式不同，所以又进
入os相关的代码，`{os}\bin\java_md.c`中的`int ContinueInNewThread0(JNICALL 
*continuation)(void *), jlong stack_size,void *args)`函数。
    
    阅读其源码，可知linux上是通过`pthread_create`创建线程，Solaris通过`thr_create`创建线程，
    而`windows`则通过`_beginthreadex`创建线程。
    
    在新线程中调用JavaMain函数，即openjdk\jdk\src\share\bin\main.c中的 `int JNICALL 
    JavaMain(void *_args)`,它负责加载要运行的的java class，并调用class的main方法。
    
    处理步骤是：
    
    1).InitalizeJVM-&amp;gt;CreateJavaVM(即通过JNI调用JNI_CreateJavaVM),创建jvm。
    2).LoadMainClass加载main class，并确保main方法的签名是正确的。 
    3).mainID = (*env)-&amp;gt;GetStaticMethodID(env, mainClass, &quot;main&quot;,&quot;([Ljava/lang/String;)V&quot;);通过JNI得到main方法的method信息。 
    4).mainArgs = NewPlatformStringArray(env, argv, argc);为main方法准备参数数组。 
    5).(*env)-&amp;gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);通过JNI调用main方法。 
    6).ret = (*env)-&amp;gt;ExceptionOccurred(env) == NULL ? 0 : 1;处理异常 
    7).DetachCurrentThread 
    8).DestroyJavaVM 销毁JVM
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;下面以windows的实现进行分析：&lt;/p&gt;

  &lt;p&gt;首先查找jre路径，Java通过&lt;code&gt;GetApplicationHome api&lt;/code&gt;来获得当前的&lt;code&gt;java.exe&lt;/code&gt;绝对路径（例如我电脑上的&lt;code&gt;e:\program
\java\jdk\bin\java.exe&lt;/code&gt;），那么它会截取到绝对路径&lt;code&gt;e:\program\java\jdk&lt;/code&gt;，判断&lt;code&gt;e:\program\java\jdk\jvm.dll&lt;/code&gt;
文件是否存在，如果存在就把&lt;code&gt;e:\program\java\jdk&lt;/code&gt;，作为jre路径；如果不存在则判断&lt;code&gt;e:\program\java\jdk\jre\jvm.dll&lt;/code&gt;
是否存在，如果存在则将&lt;code&gt;e:\program\java\jdk\jre&lt;/code&gt;作为jre路径。如果不存在调用&lt;code&gt;GetPublicJREHome&lt;/code&gt;查&lt;code&gt;HKEY_LOCAL
_MACHINE\Software\JavaSoft\Java Runtime Environment\&quot;当前JRE版本号&quot;\JavaHome&lt;/code&gt;的路径作为jre路径。&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>JavaClass文件结构</title>
   <link href="http://mastery001.github.io/java/2015/07/21/Java_class_structs"/>
   <updated>2015-07-21T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/java/2015/07/21/Java_class_structs</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;1.Class文件概述
    1.1 无符号数和表
    1.2 魔数和Class文件的版本
    1.3 常量池
        1.3.1 javap的使用
        1.3.2 常量池中的14种常量项的结构总表 
    1.4 访问标志
    1.5 类索引、父类索引和接口索引集合
    1.6 字段表集合
    1.7 方法表集合
    1.8 属性表集合
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;class&quot;&gt;1.Class文件概述&lt;/h1&gt;

&lt;p&gt;Class文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何
分隔符，这使得整个Class文件中存储的内容几乎全部是程序的必要数据，没有空隙存在。当遇到需要占用8位字节的以上的
空间的数据项时，则会按照高位在前的方式分隔成若干个8位字节进行存储。&lt;/p&gt;

&lt;p&gt;根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：
无符号和表，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;1.1 无符号数和表&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，
无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。&lt;/p&gt;

  &lt;p&gt;表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以”_info”结尾。表用于描述
有层次关系的复合结构的数据，整个Class文件本质上就是一张表。它由表6-1所示的数据项构成。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_file_format.jpg&quot; alt=&quot;Class文件格式&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;class-1&quot;&gt;1.2 魔数与Class文件的版本&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Class文件的魔数很有“浪漫气息”，值为&lt;code&gt;0xCAFEBABY&lt;/code&gt;(咖啡宝贝).&lt;/p&gt;

&lt;p&gt;紧接着魔数的4个字节值是Class文件的版本号：第5和第6个字节是次版本号（Minor Version）,第7和第8个字节是主版本号
（Major Version）。Java的版本号是从45开始的。&lt;/p&gt;

&lt;p&gt;为了方便讲解，现准备了一段最简单的Java代码（见代码清单1-1）&lt;/p&gt;

&lt;p&gt;代码清单1-1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package org.fenixsoft.clazz;

public class TestClass {
    
    private int m;
        
    public int inc() {
        return m+1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;下面是部分class文件中的内容：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/clazz_file.jpg&quot; alt=&quot;class file&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1.3 常量池&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联
最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于常量池常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如下图所示&lt;/strong&gt;
&lt;img src=&quot;/images/java_class/class_constant.jpg&quot; alt=&quot;常量池&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即二进制的22.这就代表常量池中有21项常量，索引值范围为1-21.
在Class文件格式规范制定之时，设计者将第0项常量空出来在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达
“不引用任何一个常量池项目”的含义。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近
Java语言层面的常量概念，如文本字符串,声明为final的常量值等。而符号引用则属于编译原理方面的概念，
包括了下面三类常量：
 1.类和接口的全限定名（Full Qualified Name）
 2.字段的名称和描述符（Descriptor）
 3.方法的名称和描述符
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;常量池的每一项常量都是一个表，在JDK1.7之前共有11种结构各不相同的表结构数据，在JDK1.7中为了更好支持动态语言调用，
又额外增加了3种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info、CONSTANT_InvokeDynamic_info）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这14种表都有一个共同特点，就是表开始的第一位是一个u1类型的标志位(tag，取值见下表中标志列)，代表当前常量属于哪种
常量类型.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_constant_type.jpg&quot; alt=&quot;常量池项目类型&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;javap&quot;&gt;1.3.1 javap的使用&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;在JDK的bin目录中，有一个专门用于分析Class文件字节码的工具：javap，下图列出了使用javap工具的-verbose参数输出的
TestClass.class文件字节码内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_javap_info.jpg&quot; alt=&quot;javap输出的字节码内容&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.3.2 常量池中的14种常量项的结构总表&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_constant_struct1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_constant_struct2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_constant_struct3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;1.4 访问标志&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，
包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;具体的标志位以及标志的含义见下图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_access_flags.jpg&quot; alt=&quot;access_flags&quot; /&gt;&lt;/p&gt;

&lt;p&gt;access_flags中一共有16个标志位可以使用，上图只定义了其中8个，未使用的标志位要求一律为0.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;1.5 类索引、父类索引和接口索引集合&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引集合(interfaces)是一组u2类型的数据的集合
，Class文件中由这三项数据来确定这个类的继承关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_clazz_index.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;1.6 字段表集合&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;字段表(field_info)用于描述接口或者类中声明的变量。字段(field)包括类级变量和实例级变量，但不包括在方法内部声明的
局部变量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;字段表结构：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_field_info.jpg&quot; alt=&quot;field_info&quot; /&gt;&lt;/p&gt;

&lt;p&gt;字段修饰符放在access_flags项目中，它与类中的access_flags项目非常类似的，都是一个u2的数据类型，其中可以设置的标志
位的含义见下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_field_access_flags.jpg&quot; alt=&quot;class_field_access_flags&quot; /&gt;&lt;/p&gt;

&lt;p&gt;跟随access_flags标志的两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称
以及字段和方法的描述符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;名词解释&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;全限定名：将类名中的'.'替换成'/'，例如：java.lang.Object的全限定名为java/lang/Object
   
简单名称：指没有类型和参数修饰的方法和字段名称，例如Object的equals()方法的简单名称为equals

描述符：用来描述字段的数据类型，方法的参数列表(包括数量、类型以及顺序)和返回值。根据描述符规则
基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限
定名来表示。描述数组类型时，每一维度将使用一个前置的'['字符来描述。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;描述符标识字符含义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_field_descriptor.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号`()`
之内。如方法void inc()的描述符为`()V`,方法java.lang.String()的描述符为`()Ljava/lang/String;`,
方法int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target,int targetOffset,int targetCount, int frmoIndex)的描述符为`([CII[CIII)I`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;1.7 方法表集合&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;方法表的结构与字段表的结构相同，依次包括了访问标志(access_flags)、名称索引(name_index)、描述符索引(descriptor_index)
、属性表集合(arrtibutes)几项。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;方法访问标志&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_class/class_method_access_flags.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如果父类方法在子类中没有被重写(Override)，方法表集合中就不会出现来自父类的方法信息。但同样的
，有可能会出现编译器自动添加的方法，最典型的便是类构造器`&amp;lt;clinit&amp;gt;`方法和实例构造器`&amp;lt;init&amp;gt;`方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-7&quot;&gt;1.8 属性表集合&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;具体属性表在此不作讲解，请参考《&lt;a href=&quot;http://yunpan.cn/ccWFtqyhHKAur&quot;&gt;深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）&lt;/a&gt;》的第六章&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;文件提取码是2f30&lt;/p&gt;

&lt;h1 id=&quot;section-8&quot;&gt;声明&lt;/h1&gt;

&lt;p&gt;本文摘自《&lt;a href=&quot;http://yunpan.cn/ccWFtqyhHKAur&quot;&gt;深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）&lt;/a&gt;》一书，为了更好的理解java的字节码文件。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何阅读GC日志</title>
   <link href="http://mastery001.github.io/java/2015/07/20/c_on_Java"/>
   <updated>2015-07-20T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/java/2015/07/20/c_on_Java</id>
   <content type="html">&lt;!--more--&gt;
&lt;p&gt;一名合格的java程序员应具备基本的使用JVM能力，了解其启动时的配置参数，并且能够理解GC的输出日志。&lt;/p&gt;

&lt;p&gt;阅读GC日志是处理Java虚拟机内存问题的基础技能，它只是一些认为确定的规则，没有太多技术含量。 
每一种收集器的日志形式都是由它们自身的实现而决定的，换而言之，每个收集器的日志格式都可以不一样。下面为两段典型的GC日志：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_gc/GC.jpg&quot; alt=&quot;GC典型日志&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最前面的数字&lt;code&gt;33.125;&lt;/code&gt;和&lt;code&gt;100.667;&lt;/code&gt;代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。&lt;/p&gt;

&lt;p&gt;GC日志开头的&lt;code&gt;[GC&lt;/code&gt;和&lt;code&gt;[Full GC&lt;/code&gt;说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有&lt;code&gt;Full&lt;/code&gt;，说明这次GC是发生在&lt;code&gt;Stop-the-world&lt;/code&gt;的，例如下面这段新生代收集器ParNew的日志也会出现&lt;code&gt;[Full GC&lt;/code&gt;（这一般是因为出现了分配担保失败之类的问题，所以才会导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示&lt;code&gt;[Full GC(System)&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Full GC 283.776: [ParNew: 261559K-&amp;gt;261559K(261559K),0.0000288 secs]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来的&lt;code&gt;[DefNew&lt;/code&gt;，&lt;code&gt;[Tenured&lt;/code&gt;，&lt;code&gt;[Perm&lt;/code&gt;表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器的新生代名为&lt;code&gt;Default New Generation&lt;/code&gt;，所以显示的是&lt;code&gt;[DefNew&lt;/code&gt;。如果是ParNew收集器，新生代名称就会变成&lt;code&gt;[ParNew&lt;/code&gt;，意为&lt;code&gt;Parallel New Generation&lt;/code&gt;。如果采用的是Parallel Scavenge收集器，那它配套的新生代称为&lt;code&gt;PSYoungGen&lt;/code&gt;，老年代和永久代同理，名称也是由收集器决定。&lt;/p&gt;

&lt;p&gt;后面方括号内部的&lt;code&gt;3324K-&amp;gt;152K(3712K)&lt;/code&gt;含义是&lt;code&gt;GC前该内存区域已使用容量-&amp;gt;GC后该内存区域已使用容量（该内存区域总容量）&lt;/code&gt;。而在方括号之外的&lt;code&gt;3324K-&amp;gt;152K(11904K)&lt;/code&gt;表示&lt;code&gt;GC前Java堆已使用容量-&amp;gt;GC后Java堆已使用容量（Java堆总容量）&lt;/code&gt;。 
再往后，&lt;code&gt;0.0025925 secs&lt;/code&gt;表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如&lt;code&gt;[Times: user=0.01 sys=0.02,real=0.02 secs]&lt;/code&gt;，这里面的user,sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间，内核消耗的CPU时间和操作从开始到结束的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O，等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Java_collections_set</title>
   <link href="http://mastery001.github.io/2012/07/29/Java_collections_Set"/>
   <updated>2012-07-29T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/2012/07/29/Java_collections_Set</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>Java_collections_map</title>
   <link href="http://mastery001.github.io/2012/07/29/Java_collections_Map"/>
   <updated>2012-07-29T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/2012/07/29/Java_collections_Map</id>
   <content type="html">
</content>
 </entry>
 
 <entry>
   <title>判断两个单向链表是否相交</title>
   <link href="http://mastery001.github.io/datastructure/2012/07/20/c_on_DataStructure"/>
   <updated>2012-07-20T00:00:00+08:00</updated>
   <id>http://mastery001.github.io/datastructure/2012/07/20/c_on_DataStructure</id>
   <content type="html">&lt;pre&gt;&lt;code&gt;1.链表定义
2.相交的理解
3.解决方法
    3.1 双重循环判断
    3.2 判断最后一个结点是否相同
    3.3 链表成环
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h1 id=&quot;section&quot;&gt;1.链表定义&lt;/h1&gt;

&lt;p&gt;链式存储结构存储线性表的方法是把存放数据元素的结点用指针域构造成链。指针是指向下一个节点的引用，由数据元素域和一个或若干个指针域组
成的一个类称之为结点。链式存储结构的特点是数据元素间的逻辑关系表现在节点的链接关系上。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.相交的理解&lt;/h1&gt;

&lt;p&gt;若两个链表&lt;code&gt;相交&lt;/code&gt;则其相交后的结点必定是最后一个结点或者是第k个结点能使其后面的结点连结成一条直线的结点&lt;/p&gt;

&lt;p&gt;则可以得出若两个单向链表相交，则两个链表组成的形状一定为V型或Y型。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;3.解决方法&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;可以考虑用三种方式来实现：
    (1)使用双重循环来遍历结点判断是否相同
    (2)判断两个链表的最后一个结点是否相同
    (3)将两个链表构成环
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设定链表结点的数据结构为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Node{
    DataType data;  //数据元素域
    Node next;      //指针域
} 第一个结点的引用为root；
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;3.1 双重循环判断&lt;/h2&gt;
&lt;p&gt;对两个单向链表进行循环，临界值：当第一个链表的结点与第二个链表的结点相同时返回true，反之返回false。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*  使用while进行循环迭代，条件为next不为null
*/
while root1 != null
begin
    while root2 != null
    begin
        if root1 == root2 then do return true
        end if
    end
end
return false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间复杂度分析： 最好的情况下是root1==root2,此时只循环一次，时间复杂度为O(1),最坏情况下是两个链表的最后
一个结点相等时，循环需要n*n次，即时间复杂度为O(n2).&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;3.2 判断最后一个结点是否相同&lt;/h2&gt;
&lt;p&gt;得到两个单向链表的最后一个结点，临界值：两个结点相同时返回true，反之返回false&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*   用root1指代第一个链表的头结点，root2指代第二个链表的头结点
*/
while root1 != null
begin
    root1 = root1.next
end

while root2 != null
begin
    root2 = root2.next
end

if root1 == root2 then return true
else 
    return false
end if
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间复杂度分析： 该算法的时间复杂度在最好和最坏的情况下都是O(n)，都必须循环n次到尾结点。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;3.3 链表成环&lt;/h2&gt;
&lt;p&gt;假设两个链表尾部相连能够构成环，则一个链表的首结点遍历到末尾结点必然是另一个链表的首结点。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
*   该程序的先觉条件是必须在两个链表已经构成环的基础上可执行
*/
while root1 != null
begin 
    root1 = root1.next
end
if root1 == root2 then return true
return false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间复杂度分析： 该算法的时间复杂度在最好和最坏的情况下都是O(n)，都必须循环n次到尾结点。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
